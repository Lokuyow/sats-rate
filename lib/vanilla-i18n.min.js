"use strict";

const MSG_LEVELS = ["DEBUG", "INFO", "WARN", "ERROR"],
    DEFAULT_i18n_DATA_ATTR = "vanilla-i18n",
    DEFAULT_i18n_DIR = "assets/vanilla-i18n",
    DEFAULT_LANG_TOGGLER_ID = "vanilla-i18n-toggler";

class vanilla_i18n {
    constructor(languages, options) {
        this._languages = languages;
        this._path = this._sanitizePath(options.path || DEFAULT_i18n_DIR);
        this._debug = options.debug || false;
        this._i18nDataAttr = options.i18n_attr_name || DEFAULT_i18n_DATA_ATTR;
        this._localStorageKey = this._generateKeyFromHost();
        this._togglerID = options.toggler_id || DEFAULT_LANG_TOGGLER_ID;
        options.default_language || (options.default_language = this._languages[0]);
        this._translationData = null; // 翻訳データを保持するプロパティを追加

        this._initializeLanguage(options.default_language);
        document.addEventListener("DOMContentLoaded", () => {
            this._attachOnChangeToi18nToggler(this._togglerID);
        });
    }

    _initializeLanguage(defaultLanguage) {
        const savedLanguage = this._getLanguage();
        if (!savedLanguage) {
            const browserLanguage = navigator.language || navigator.userLanguage;
            let matchedLanguage;
            if (browserLanguage === "ja-JP") {
                matchedLanguage = "日本語";
            } else {
                matchedLanguage = defaultLanguage;
            }
            this._setSavedLanguage(matchedLanguage);
            this._printMsg(`No saved language found, setting browser language or default: ${matchedLanguage}`, MSG_LEVELS[2]);
        }
    }

    async run() {
        const selectedLanguage = this._getLanguage();
        if (selectedLanguage && !this._languages.includes(selectedLanguage)) {
            this._printMsg(`unsupported ${selectedLanguage} language found in local storage, supported languages are ${this._languages}`, MSG_LEVELS[3]);
            return;
        }
        if (!selectedLanguage) {
            this._printMsg(`no set language found, default language will be used`, MSG_LEVELS[2]);
            return;
        }
        document.addEventListener("DOMContentLoaded", () => {
            this._setTogglerValue(selectedLanguage, this._togglerID);
        });
        const languageData = await this._loadLangFile(selectedLanguage);
        if (!languageData) {
            this._printMsg(`failed to load translation file for ${selectedLanguage}`, MSG_LEVELS[3]);
            return;
        }
        this._translationData = languageData; // 翻訳データを保存
        const elements = this._getElementsForTranslation();
        if (!elements) {
            this._printMsg(`no element found for translating`, MSG_LEVELS[2]);
            return;
        }
        this._translate(elements, languageData);
        this._printMsg(`translation to ${selectedLanguage} finished for ${elements.length} elements`, MSG_LEVELS[0]);
    }

    // _runOnChange メソッドを非同期関数に変更
    async _runOnChange(selectedLanguage) {
        if (!this._languages.includes(selectedLanguage)) {
            this._printMsg(`${selectedLanguage} is not supported, supported languages are ${this._languages}`, MSG_LEVELS[3]);
            return;
        }
        const currentLanguage = this._getLanguage();
        if (selectedLanguage == currentLanguage) {
            this._printMsg(`selected language is same as current language`, MSG_LEVELS[0]);
        } else {
            this._printMsg(`switching to ${selectedLanguage} from ${currentLanguage}`, MSG_LEVELS[1]);
            this._setSavedLanguage(selectedLanguage);

            // 翻訳データのロードを待つ
            await this.run();

            // 言語変更のカスタムイベントを発行（翻訳データのロード完了後）
            const event = new CustomEvent('languageChange', { detail: { language: selectedLanguage } });
            window.dispatchEvent(event);
        }
    }

    _attachOnChangeToi18nToggler(togglerID) {
        const toggler = document.getElementById(togglerID);
        if (toggler) {
            // イベントハンドラを非同期関数に変更
            toggler.addEventListener("change", async (event) => {
                await this._runOnChange(event.target.value);
            });
        } else {
            this._printMsg(`no language toggler found with id "${togglerID}" for attaching onChange event`, MSG_LEVELS[2]);
        }
    }

    _setTogglerValue(language, togglerID) {
        const toggler = document.getElementById(togglerID);
        if (toggler) {
            toggler.value = language;
            toggler.dispatchEvent(new Event("change"));
        } else {
            this._printMsg(`no language toggler found with id "${togglerID}" for setting value`, MSG_LEVELS[2]);
        }
    }

    _translate(elements, languageData = undefined) {
        if (languageData) {
            elements.forEach((element) => {
                const keys = element.getAttribute(this._i18nDataAttr).split(".");
                const translation = keys.reduce((obj, key) => obj[key], languageData);
                if (translation) {
                    element.innerHTML = translation;
                }
            });
        }
    }

    _getElementsForTranslation() {
        return document.querySelectorAll("[" + this._i18nDataAttr + "]");
    }

    async _loadLangFile(language = undefined) {
        if (language) {
            const url = `/${this._path}/${language}.json`;
            try {
                const response = await fetch(url);
                return response.json();
            } catch (error) {
                this._printMsg(`Error loading language file: ${error}`, MSG_LEVELS[3]);
            }
        }
    }

    _getLanguage() {
        const savedLanguage = this._getSavedLanguage();
        if (!savedLanguage) {
            this._printMsg("no saved language found, default language will load", MSG_LEVELS[0]);
        }
        return savedLanguage;
    }

    _getSavedLanguage() {
        return window.localStorage.getItem(this._localStorageKey);
    }

    _setSavedLanguage(language) {
        if (language) {
            window.localStorage.setItem(this._localStorageKey, language);
        }
    }

    _generateKeyFromHost() {
        return window.location.host + "-vanilla-i18n";
    }

    _sanitizePath(path) {
        path = path.trim();
        if (path[0] === "/") {
            path = path.slice(1);
        }
        if (path[path.length - 1] === "/") {
            path = path.slice(0, -1);
        }
        return path;
    }

    _printMsg(message, level) {
        if (level !== MSG_LEVELS[0] || this._debug) {
            console.info("vanilla-i18n | " + level + ": " + message);
        }
    }

    // 追加したtranslateメソッド
    translate(key, variables = {}) {
        if (!this._translationData) {
            this._printMsg(`Translation data is not loaded yet`, MSG_LEVELS[2]);
            return '';
        }
        const keys = key.split('.');
        let translation = this._translationData;
        for (let k of keys) {
            translation = translation[k];
            if (translation === undefined) {
                this._printMsg(`No translation found for key: ${key}`, MSG_LEVELS[2]);
                return '';
            }
        }
        // プレースホルダーを置換
        if (typeof translation === 'string') {
            Object.keys(variables).forEach((variable) => {
                const regex = new RegExp(`{${variable}}`, 'g');
                translation = translation.replace(regex, variables[variable]);
            });
        }
        return translation;
    }
}

/*
 * Original library: vanilla-i18n
 * Original copyright (c) 2020 Shivam Kumar Jha
 * Modified by Lokuyow in 2024
 *
 * This code has been modified from the original version.
 *
 * MIT License
 * 
 * Copyright (c) 2020 Shivam Kumar Jha
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
