"use strict";

const MSG_LEVELS = ["DEBUG", "INFO", "WARN", "ERROR"],
  DEFAULT_i18n_DATA_ATTR = "vanilla-i18n",
  DEFAULT_i18n_DIR = "assets/vanilla-i18n",
  DEFAULT_LANG_TOGGLER_ID = "vanilla-i18n-button";

class vanilla_i18n {
  constructor(languages, options) {
    this._languages = languages;
    this._path = this._sanitizePath(options.path || DEFAULT_i18n_DIR);
    this._debug = options.debug || false;
    this._i18nDataAttr = options.i18n_attr_name || DEFAULT_i18n_DATA_ATTR;
    this._localStorageKey = this._generateKeyFromHost();
    this._togglerID = options.toggler_id || null; // デフォルトIDを使用しない
    options.default_language || (options.default_language = this._languages[0]);
    this._translationData = null; // 翻訳データを保持するプロパティを追加

    this._initializeLanguage(options.default_language);
    document.addEventListener("DOMContentLoaded", () => {
      // DOMContentLoaded でトグラーの値を設定し、イベントリスナーをアタッチ
      const initialLanguage = this._getLanguage();
      if (initialLanguage) {
        this._setTogglerValue(initialLanguage, this._togglerID);
      }
      this._attachOnChangeToi18nToggler(this._togglerID);
    });
  }

  _initializeLanguage(defaultLanguage) {
    const savedLanguage = this._getLanguage();
    if (!savedLanguage) {
      const browserLanguage = navigator.language || navigator.userLanguage;
      let matchedLanguage;
      if (browserLanguage === "ja-JP") {
        matchedLanguage = "日本語";
      } else {
        matchedLanguage = defaultLanguage;
      }
      this._setSavedLanguage(matchedLanguage);
      this._printMsg(`No saved language found, setting browser language or default: ${matchedLanguage}`, MSG_LEVELS[2]);
    }
  }

  async run() {
    const selectedLanguage = this._getLanguage();
    if (selectedLanguage && !this._languages.includes(selectedLanguage)) {
      this._printMsg(`unsupported ${selectedLanguage} language found in local storage, supported languages are ${this._languages}`, MSG_LEVELS[3]);
      return;
    }
    if (!selectedLanguage) {
      this._printMsg(`no set language found, default language will be used`, MSG_LEVELS[2]);
      return;
    }
    // _setTogglerValue は constructor の DOMContentLoaded で初期設定されるため、ここでは呼び出し不要。

    const languageData = await this._loadLangFile(selectedLanguage);
    if (!languageData) {
      this._printMsg(`failed to load translation file for ${selectedLanguage}`, MSG_LEVELS[3]);
      return;
    }
    this._translationData = languageData; // 翻訳データを保存
    const elements = this._getElementsForTranslation();
    if (!elements) {
      this._printMsg(`no element found for translating`, MSG_LEVELS[2]);
      return;
    }
    this._translate(elements, languageData);
    this._printMsg(`translation to ${selectedLanguage} finished for ${elements.length} elements`, MSG_LEVELS[0]);
  }

  // _runOnChange メソッドを非同期関数に変更
  async _runOnChange(selectedLanguage) {
    if (!this._languages.includes(selectedLanguage)) {
      this._printMsg(`${selectedLanguage} is not supported, supported languages are ${this._languages}`, MSG_LEVELS[3]);
      return;
    }
    const currentLanguage = this._getLanguage();
    if (selectedLanguage == currentLanguage) {
      this._printMsg(`selected language is same as current language`, MSG_LEVELS[0]);
    } else {
      this._printMsg(`switching to ${selectedLanguage} from ${currentLanguage}`, MSG_LEVELS[1]);
      this._setSavedLanguage(selectedLanguage);

      // 翻訳データのロードを待つ
      await this.run();

      // 言語変更のカスタムイベントを発行（翻訳データのロード完了後）
      const event = new CustomEvent("languageChange", { detail: { language: selectedLanguage } });
      window.dispatchEvent(event);
    }
  }

  _attachOnChangeToi18nToggler(togglerID) {
    if (!togglerID) return; // トグルIDが設定されていない場合は何もしない

    const toggler = document.getElementById(togglerID);
    if (toggler) {
      if (toggler.tagName.toLowerCase() === 'select') { // select要素の場合
        toggler.addEventListener("change", async (event) => {
          await this._runOnChange(event.target.value);
        });
      } else if (toggler.tagName.toLowerCase() === 'button') { // button要素の場合
        toggler.addEventListener("click", async () => { // 'click'イベントに変更
          const currentLanguage = this._getLanguage();
          const currentIndex = this._languages.indexOf(currentLanguage);
          const nextIndex = (currentIndex + 1) % this._languages.length;
          const nextLanguage = this._languages[nextIndex];
          await this._runOnChange(nextLanguage);
        });
      }
    } else {
      // トグルIDが提供されていた場合のみ警告を出す
      this._printMsg(`no language toggler found with id "${togglerID}" for attaching event`, MSG_LEVELS[2]);
    }
  }

  _setTogglerValue(language, togglerID) {
    if (!togglerID) return; // トグルIDが設定されていない場合は何もしない

    const toggler = document.getElementById(togglerID);
    if (toggler) {
      if (toggler.tagName.toLowerCase() === 'select') { // select要素の場合
        toggler.value = language;
        // dispatchEvent(new Event("change")) は不要。初期化時にrun()が呼ばれる。
      }
      // ボタンの場合、value属性はないので何もしない。
      // aria-labelなどは_translateメソッドで更新される。
    } else {
      // トグルIDが提供されていた場合のみ警告を出す
      this._printMsg(`no language toggler found with id "${togglerID}" for setting value`, MSG_LEVELS[2]);
    }
  }

  _translate(elements, languageData = undefined) {
    if (languageData) {
      elements.forEach((element) => {
        // vanilla-i18n属性の処理
        if (element.hasAttribute(this._i18nDataAttr)) {
          const keys = element.getAttribute(this._i18nDataAttr).split(".");
          const translation = keys.reduce((obj, key) => obj && obj[key], languageData);
          if (translation) {
            if (element.tagName.toLowerCase() !== "input" && element.tagName.toLowerCase() !== "textarea") {
              element.innerHTML = translation;
            }
          }
        }

        // vanilla-i18n-title属性の処理
        const titleAttr = this._i18nDataAttr + "-title";
        if (element.hasAttribute(titleAttr)) {
          const titleKeys = element.getAttribute(titleAttr).split(".");
          const titleTranslation = titleKeys.reduce((obj, key) => obj && obj[key], languageData);
          if (titleTranslation) {
            element.setAttribute("title", titleTranslation);
          }
        }

        // vanilla-i18n-placeholder属性の処理
        const placeholderAttr = this._i18nDataAttr + "-placeholder";
        if (element.hasAttribute(placeholderAttr)) {
          const placeholderKeys = element.getAttribute(placeholderAttr).split(".");
          const placeholderTranslation = placeholderKeys.reduce((obj, key) => obj && obj[key], languageData);
          if (placeholderTranslation) {
            element.setAttribute("placeholder", placeholderTranslation);
          }
        }

        // vanilla-i18n-aria-label属性の処理
        const ariaLabelAttr = this._i18nDataAttr + "-aria-label";
        if (element.hasAttribute(ariaLabelAttr)) {
          const ariaLabelKeys = element.getAttribute(ariaLabelAttr).split(".");
          const ariaLabelTranslation = ariaLabelKeys.reduce((obj, key) => obj && obj[key], languageData);
          if (ariaLabelTranslation) {
            element.setAttribute("aria-label", ariaLabelTranslation);
          }
        }
      });
    }
  }

  _getElementsForTranslation() {
    return document.querySelectorAll(`[${this._i18nDataAttr}], [${this._i18nDataAttr}-title], [${this._i18nDataAttr}-placeholder], [${this._i18nDataAttr}-aria-label]`);
  }

  async _loadLangFile(language = undefined) {
    if (language) {
      const url = `/${this._path}/${language}.json`;
      try {
        const response = await fetch(url);
        return response.json();
      } catch (error) {
        this._printMsg(`Error loading language file: ${error}`, MSG_LEVELS[3]);
      }
    }
  }

  _getLanguage() {
    const savedLanguage = this._getSavedLanguage();
    if (!savedLanguage) {
      this._printMsg("no saved language found, default language will load", MSG_LEVELS[0]);
    }
    return savedLanguage;
  }

  _getSavedLanguage() {
    return window.localStorage.getItem(this._localStorageKey);
  }

  _setSavedLanguage(language) {
    if (language) {
      window.localStorage.setItem(this._localStorageKey, language);
    }
  }

  _generateKeyFromHost() {
    return window.location.host + "-vanilla-i18n";
  }

  _sanitizePath(path) {
    path = path.trim();
    if (path[0] === "/") {
      path = path.slice(1);
    }
    if (path[path.length - 1] === "/") {
      path = path.slice(0, -1);
    }
    return path;
  }

  _printMsg(message, level) {
    if (level !== MSG_LEVELS[0] || this._debug) {
      console.info("vanilla-i18n | " + level + ": " + message);
    }
  }

  // 追加したtranslateメソッド
  translate(key, variables = {}) {
    if (!this._translationData) {
      this._printMsg(`Translation data is not loaded yet`, MSG_LEVELS[2]);
      return "";
    }
    const keys = key.split(".");
    let translation = this._translationData;
    for (let k of keys) {
      translation = translation[k];
      if (translation === undefined) {
        this._printMsg(`No translation found for key: ${key}`, MSG_LEVELS[2]);
        return "";
      }
    }
    // プレースホルダーを置換
    if (typeof translation === "string") {
      Object.keys(variables).forEach((variable) => {
        const regex = new RegExp(`{${variable}}`, "g");
        translation = translation.replace(regex, variables[variable]);
      });
    }
    return translation;
  }
}

/*
 * Original library: vanilla-i18n
 * Original copyright (c) 2020 Shivam Kumar Jha
 * Modified by Lokuyow in 2024
 *
 * This code has been modified from the original version.
 *
 * MIT License
 *
 * Copyright (c) 2020 Shivam Kumar Jha
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
